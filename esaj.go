// Package esaj from esaj.go is a package that provides functions to interact with the TJSP website.
// The function names follow the same naming convention as the original API.
package esaj

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

// SearchDo searches for a specific process in the TJSP website and return the processCode. An ID in the format 1H000H91J0000.
// - cookieSession: The dynamic cookie generated by the TJSP. This should be include the JSESSIONID and K-JSESSIONID-nckcjpip.
// - processID: The process ID in the format: 0000001-02.2021.8.26.0000
// Example of cookieSession: "JSESSIONID=EACA3333A48456D7953B6331999A4F80.cas11; K-JSESSIONID-nckcjpip=0E4D006FFD78524DBABA78F02E1633FA"
func SearchDo(cookieSession string, processID string) (string, error) {
	client := &http.Client{}

	numeroDigitoAnoUnificado, err := numeroDigitoAnoUnificado(processID)
	if err != nil {
		return "", err
	}

	foroNumeroUnificado, err := foroNumeroUnificado(processID)
	if err != nil {
		return "", err
	}

	urlFormated := fmt.Sprintf(`https://esaj.tjsp.jus.br/cpopg/search.do?conversationId=&cbPesquisa=NUMPROC&numeroDigitoAnoUnificado=%s&foroNumeroUnificado=%s&dadosConsulta.valorConsultaNuUnificado=%s&dadosConsulta.valorConsultaNuUnificado=UNIFICADO&dadosConsulta.valorConsulta=&dadosConsulta.tipoNuProcesso=UNIFICADO`, numeroDigitoAnoUnificado, foroNumeroUnificado, processID)

	req, err := http.NewRequest("GET", urlFormated, nil)
	if err != nil {
		return "", fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Cookie", cookieSession)

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("error doing request: %w", err)
	}

	defer func() {
		_ = resp.Body.Close()
	}()

	bodyByte, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading body: %w", err)
	}

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(bodyByte)))

	if err != nil {
		return "", fmt.Errorf("error initializing goquery new document from reader: %w", err)
	}

	var link string
	doc.Find("tr > td > a.linkMovVincProc").EachWithBreak(func(_ int, s *goquery.Selection) bool {
		href, _ := s.Attr("href")
		if strings.Contains(href, "abrirDocumentoVinculadoMovimentacao.do") {
			link = href
			return false
		}
		return true
	})

	regex := regexp.MustCompile(`processo.codigo=(\w+)`)
	matches := regex.FindStringSubmatch(link)
	if len(matches) == 0 {
		return "", fmt.Errorf("no matches found when searching for processCode")
	}

	processCode := matches[1]
	return processCode, nil
}

// pastaDigitalURL fetch the html page and return the URL where the pdf documents can be downloaded.
// - processCode: The process code in the format: 1H000H91J0000
// - cookieSession: The dynamic cookie generated by the TJSP. This should be include the JSESSIONID and K-JSESSIONID-nckcjpip.
// Example of cookieSession: "JSESSIONID=EACA3333A48456D7953B6331999A4F80.cas11; K-JSESSIONID-nckcjpip=0E4D006FFD78524DBABA78F02E1633FA"
func pastaDigitalURL(cookieSession, processCode string) (string, error) {
	formatedURL := fmt.Sprintf("https://esaj.tjsp.jus.br/cpopg/abrirPastaDigital.do?processo.codigo=%s", processCode)

	client := &http.Client{}
	req, err := http.NewRequest("GET", formatedURL, nil)
	if err != nil {
		return "", fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Cookie", cookieSession)

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("error doing request: %w", err)
	}

	bodyByte, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading body: %w", err)
	}

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(bodyByte)))
	if err != nil {
		return "", fmt.Errorf("error initializing goquery new document from reader: %w", err)
	}

	var link string
	doc.Find("body").First().Each(func(_ int, s *goquery.Selection) {
		link = s.Text()
	})

	if link == "" {
		return "", fmt.Errorf("no link found")
	}

	if strings.Contains(link, "Não foi possível validar o seu acesso") {
		return "", fmt.Errorf("access not validated, verify the COOKIESESSION")
	}

	return link, nil
}

// AbrirPastaProcessoDigital fetches the digital folder page where all structured data of the process can be found.
// This data is used to download the PDF documents related to the process.
// - processCode: The process code in the format: 1H000H91J0000
// - cookieSession: The dynamic cookie generated by the TJSP. This should be include the JSESSIONID and K-JSESSIONID-nckcjpip.
// Example of cookieSession: "JSESSIONID=EACA3333A48456D7953B6331999A4F80.cas11; K-JSESSIONID-nckcjpip=0E4D006FFD78524DBABA78F02E1633FA"
func AbrirPastaProcessoDigital(cookieSession, processCode string) ([]Process, error) {
	url, err := pastaDigitalURL(cookieSession, processCode)
	if err != nil {
		return nil, fmt.Errorf("error getting pasta digital url: %w", err)
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error doing request: %w", err)
	}

	defer func() {
		_ = resp.Body.Close()
	}()

	bodyByte, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading body: %w", err)
	}

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(bodyByte)))
	if err != nil {
		return nil, fmt.Errorf("error initializing goquery new document from reader: %w", err)
	}

	// into the script tag, we can find the requestScope that contains the structured data of the process.
	// this data after parsed, can be used to download the PDF documents.
	var scriptContent string
	doc.Find("script").Each(func(_ int, s *goquery.Selection) {
		scriptContent = s.Text()
	})

	if scriptContent == "" {
		return nil, fmt.Errorf("no script content found")
	}

	regex := regexp.MustCompile(`var requestScope = (.*);`)
	matches := regex.FindStringSubmatch(scriptContent)
	if len(matches) == 0 {
		return nil, fmt.Errorf("no matches found when searching for requestScope")
	}

	err = os.WriteFile("request_scope.json", []byte(matches[1]), 0644)
	if err != nil {
		return nil, fmt.Errorf("error writing file: %w", err)
	}

	var processes []Process
	err = json.Unmarshal([]byte(matches[1]), &processes)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling json: %w", err)
	}

	return processes, nil
}

// GetPDF fetch the pdf document from the TJSP website.
func GetPDF(cookiePDFSession, param string) error {
	hrefGetPDF := "https://esaj.tjsp.jus.br/pastadigital/getPDF.do?" + param

	req, err := http.NewRequest("GET", hrefGetPDF, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Cookie", cookiePDFSession)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("error doing request %w", err)
	}

	defer func() {
		_ = resp.Body.Close()
	}()

	bodyByte, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("error reading body: %w", err)
	}

	if strings.Contains(string(bodyByte), "Sua sessão expirou") {
		return fmt.Errorf("session expired")
	}

	//TODO(@perebaj) remove this necessity of writing the file to disk
	dt := time.Now().Format("2006-01-02T15:04:05")
	randomName := fmt.Sprintf("tmp/documento_%s.pdf", dt)
	err = os.WriteFile(randomName, bodyByte, 0644)
	if err != nil {
		return fmt.Errorf("error writing file: %w", err)
	}

	return nil
}

// processeID input example: 0000001-02.2021.8.26.0000
// numeroDigitoAnoUnificado output example: 0000001-02.2021.
func numeroDigitoAnoUnificado(processID string) (string, error) {
	regex := regexp.MustCompile(`(\d{7}-\d{2}.\d{4})`)
	matches := regex.FindStringSubmatch(processID)
	if len(matches) == 0 {
		return "", fmt.Errorf("no matches found when searching for numeroDigitoAnoUnificado. processID input: %s", processID)
	}
	return matches[1], nil
}

// processeID input example: 0000001-02.2021.8.26.0054
// foroNumeroUnificado output example: 0054. The last four digits of the processID
func foroNumeroUnificado(processID string) (string, error) {
	regex := regexp.MustCompile(`(\d{7})-(\d{2}).(\d{4}).(\d{1}).(\d{2}).(\d{4})`)
	matches := regex.FindStringSubmatch(processID)
	if len(matches) == 0 {
		return "", fmt.Errorf("no matches found when searching for foroNumeroUnificado. processID input: %s", processID)
	}

	return matches[6], nil
}
